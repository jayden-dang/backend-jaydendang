version: 2.1

orbs:
  docker: circleci/docker@2.5.0

commands:
  health-check:
    description: "Check application health"
    steps:
      - run:
          name: Health check
          command: |
            for i in {1..30}; do
              if curl -f http://$EC2_HOST:8080/health; then
                echo "‚úÖ Application is healthy"
                exit 0
              fi
              echo "‚è≥ Waiting for application to be healthy... ($i/30)"
              sleep 10
            done
            echo "‚ùå Application failed to become healthy"
            exit 1

  notify-discord:
    description: "Send notification to Discord"
    parameters:
      status:
        type: string
        default: "success"
    steps:
      - run:
          name: Notify Discord
          when: always
          command: |
            if [ "<< parameters.status >>" = "success" ]; then
              EMOJI="‚úÖ"
              COLOR="3066993"
            else
              EMOJI="‚ùå"
              COLOR="15158332"
            fi

            curl -H "Content-Type: application/json" \
                 -d "{
                   \"embeds\": [{
                     \"title\": \"$EMOJI Deployment << parameters.status >>!\",
                     \"color\": $COLOR,
                     \"fields\": [
                       {\"name\": \"Repository\", \"value\": \"$CIRCLE_PROJECT_REPONAME\", \"inline\": true},
                       {\"name\": \"Branch\", \"value\": \"$CIRCLE_BRANCH\", \"inline\": true},
                       {\"name\": \"Environment\", \"value\": \"Production\", \"inline\": true},
                       {\"name\": \"Commit\", \"value\": \"[\`${CIRCLE_SHA1:0:7}\`](https://github.com/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/commit/$CIRCLE_SHA1)\", \"inline\": true},
                       {\"name\": \"Author\", \"value\": \"$CIRCLE_USERNAME\", \"inline\": true},
                       {\"name\": \"URL\", \"value\": \"[https://jaydendang.com](https://jaydendang.com)\", \"inline\": true}
                     ],
                     \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\"
                   }]
                 }" \
                 $DISCORD_WEBHOOK || echo "Discord notification failed"

jobs:
  test:
    docker:
      - image: cimg/rust:1.87  # Match v·ªõi Dockerfile version
    steps:
      - checkout
      - run:
          name: Setup Rust
          command: |
            rustup default stable
            rustup update
      # Uncomment if you want to run tests
      # - run:
      #     name: Run tests
      #     command: cargo test

  build-and-push:
    machine:
      image: ubuntu-2204:2023.10.1
    steps:
      - checkout

      - run:
          name: Debug Environment
          command: |
            echo "üîç Environment Debug:"
            echo "DOCKER_USERNAME: $DOCKER_USERNAME"
            echo "DOCKER_PASSWORD length: ${#DOCKER_PASSWORD}"
            echo "DOCKER_IMAGE: $DOCKER_IMAGE"
            echo "CIRCLE_SHA1: $CIRCLE_SHA1"

      - run:
          name: Docker Login
          command: |
            if [ -z "$DOCKER_USERNAME" ] || [ -z "$DOCKER_PASSWORD" ]; then
              echo "‚ùå Error: DOCKER_USERNAME or DOCKER_PASSWORD not set"
              exit 1
            fi
            echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
            echo "‚úÖ Docker login successful"

      - docker/build:
          image: ${DOCKER_IMAGE}
          tag: ${CIRCLE_SHA1},latest
          platform: linux/amd64  # ƒê·∫£m b·∫£o build cho ƒë√∫ng platform

      - docker/push:
          image: ${DOCKER_IMAGE}
          tag: ${CIRCLE_SHA1},latest

  deploy:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout

      - add_ssh_keys:
          fingerprints:
            - "SHA256:ENhurBCbrBDltZ/4Q4bMgpvZ5CHicezLiHniatYkhQU"

      - run:
          name: Deploy to Ubuntu EC2
          command: |
            echo "üöÄ Starting deployment to Ubuntu EC2..."

            ssh -o StrictHostKeyChecking=no ubuntu@$EC2_HOST "
              echo 'üîß Environment Setup'
              export DOCKER_USERNAME='$DOCKER_USERNAME'
              export DOCKER_PASSWORD='$DOCKER_PASSWORD'
              export DOCKER_IMAGE='$DOCKER_IMAGE'
              export CIRCLE_SHA1='$CIRCLE_SHA1'

              echo 'üê≥ Docker Login on EC2'
              echo \$DOCKER_PASSWORD | docker login -u \$DOCKER_USERNAME --password-stdin

              echo 'üîå Create custom network if not exists'
              docker network create jaydenblog-network 2>/dev/null || echo 'Network already exists'

              echo 'üõë Stopping existing containers'
              docker stop jaydenblog jd-database redis 2>/dev/null || true
              docker rm jaydenblog jd-database redis 2>/dev/null || true

              echo 'üóÑÔ∏è  Starting PostgreSQL'
              docker run -d \
                --name jd-database \
                --restart unless-stopped \
                --network jaydenblog-network \
                -e POSTGRES_USER=jayden \
                -e POSTGRES_PASSWORD=postgres \
                -e POSTGRES_DB=jaydenblog \
                -v postgres_data:/var/lib/postgresql/data \
                postgres:16-alpine

              echo 'üî¥ Starting Redis'
              docker run -d \
                --name redis \
                --restart unless-stopped \
                --network jaydenblog-network \
                -v redis_data:/data \
                redis:7.2-alpine

              echo '‚è≥ Waiting for databases to be ready...'
              sleep 20

              # Wait for PostgreSQL to be ready
              for i in {1..30}; do
                if docker exec jd-database pg_isready -U jayden -d jaydenblog; then
                  echo '‚úÖ PostgreSQL is ready!'
                  break
                fi
                echo \"‚è≥ Waiting for PostgreSQL... (\$i/30)\"
                sleep 3
              done

              # Wait for Redis to be ready
              for i in {1..10}; do
                if docker exec redis redis-cli ping | grep -q PONG; then
                  echo '‚úÖ Redis is ready!'
                  break
                fi
                echo \"‚è≥ Waiting for Redis... (\$i/10)\"
                sleep 2
              done

              echo 'üì¶ Pulling latest application image'
              docker pull \$DOCKER_IMAGE:\$CIRCLE_SHA1

              echo 'üöÄ Starting application'
              docker run -d \
                --name jaydenblog \
                --restart unless-stopped \
                --network jaydenblog-network \
                -p 8080:8080 \
                -e DATABASE_URL=postgres://jayden:postgres@jd-database:5432/jaydenblog \
                -e REDIS_URL=redis://redis:6379/ \
                -e WEB_ADDR=0.0.0.0:8080 \
                -e RUST_LOG=info \
                -e RUST_BACKTRACE=1 \
                \$DOCKER_IMAGE:\$CIRCLE_SHA1

              echo '‚è≥ Waiting for application to start...'
              sleep 15

              echo 'üìä Deployment Status'
              echo '=== Container Status ==='
              docker ps -a | grep -E '(jd-database|redis|jaydenblog)'

              echo '=== Network Status ==='
              docker network inspect jaydenblog-network | grep -A 5 Containers || true

              echo '=== Application Logs (last 30 lines) ==='
              docker logs jaydenblog --tail 30 2>/dev/null || echo 'No logs yet'

              echo '=== Database Connection Test ==='
              docker exec jd-database psql -U jayden -d jaydenblog -c 'SELECT version();' || echo 'DB connection failed'

              echo '‚úÖ Deployment completed!'
            "

      - health-check
      - notify-discord:
          status: "success"

  cleanup:
    docker:
      - image: cimg/base:stable
    steps:
      - add_ssh_keys:
          fingerprints:
            - "SHA256:ENhurBCbrBDltZ/4Q4bMgpvZ5CHicezLiHniatYkhQU"

      - run:
          name: Cleanup Docker Resources
          command: |
            echo "üßπ Starting cleanup on EC2..."

            ssh -o StrictHostKeyChecking=no ubuntu@$EC2_HOST "
              echo 'üìä Disk usage before cleanup:'
              df -h
              docker system df

              echo 'üóëÔ∏è  Cleaning up old images (keeping latest 3)'
              # Keep only latest 3 versions of our app image
              docker images \$DOCKER_IMAGE --format 'table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}' | \
                tail -n +2 | sort -k2 -r | tail -n +4 | awk '{print \$1}' | \
                xargs -r docker rmi 2>/dev/null || true

              echo 'üßΩ Cleaning up unused resources'
              # Remove unused images, containers, networks (preserve volumes for data)
              docker system prune -f
              docker image prune -f

              # Clean up old container logs (older than 7 days)
              sudo find /var/lib/docker/containers/ -name '*.log' -mtime +7 -delete 2>/dev/null || true

              echo 'üìä Disk usage after cleanup:'
              df -h
              docker system df

              echo 'üê≥ Running containers:'
              docker ps

              echo '‚úÖ Cleanup completed!'
            "

      - notify-discord:
          status: "cleanup completed"

workflows:
  version: 2
  build-test-deploy:
    jobs:
      - test

      - build-and-push:
          requires:
            - test
          filters:
            branches:
              only: main

      - deploy:
          requires:
            - build-and-push
          filters:
            branches:
              only: main
          context:
            - default  # Add your context name if using

      - cleanup:
          requires:
            - deploy
          filters:
            branches:
              only: main
          # Run cleanup 1 hour after deployment
          # Uncomment the schedule below for automatic cleanup
          # schedule:
          #   cron: "0 */6 * * *"  # Every 6 hours
